# backtesting_framework/strategy/base_strategy.py

from abc import ABC, abstractmethod
from typing import List, Optional, Any, Dict # Added Dict
from datetime import datetime

# Assuming Event and specific event types are accessible, e.g., via a higher-level package
# For now, let's assume direct import path or it will be adjusted when backtester is built
from ..core.event import MarketEvent, SignalEvent, EventType # Relative import, Added EventType
# from backtesting_framework.core.event import MarketEvent, SignalEvent # Absolute import if structure allows

# Forward declaration for type hinting if Portfolio object is complex
# from ..core.portfolio import Portfolio # Or a snapshot/interface of it

class Strategy(ABC):
    """
    Abstract Base Class for all trading strategies.
    
    The role of a Strategy object is to generate SignalEvents based on
    MarketEvents (or other data).
    """
    def __init__(self, strategy_id: str, description: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        """
        Initializes the base strategy.

        Args:
            strategy_id (str): A unique identifier for this strategy instance.
            description (Optional[str]): A human-readable description of the strategy.
            params (Optional[Dict[str, Any]]): Strategy-specific parameters.
        """
        self.strategy_id = strategy_id
        self.description = description if description else self.__class__.__name__
        self.params = params if params else {}
        self.subscribed_tickers: List[str] = [] # List of tickers this strategy is interested in

    def __repr__(self):
        return f"{self.__class__.__name__}(id='{self.strategy_id}', params={self.params})"

    def subscribe_tickers(self, tickers: List[str]):
        """
        Allows the strategy to specify which tickers it needs market data for.
        This can be used by the DataHandler to only provide relevant data.
        """
        self.subscribed_tickers = list(set(self.subscribed_tickers + tickers)) # Avoid duplicates

    @abstractmethod
    def calculate_signals(self, event: MarketEvent, 
                          # portfolio_snapshot: Optional[Any] = None, # More complex state
                          # historical_data: Optional[Any] = None      # Access to historical bars
                         ) -> List[SignalEvent]:
        """
        Calculates a list of trading signals based on the incoming market event
        and potentially other data like historical bars or portfolio state.

        Args:
            event (MarketEvent): The MarketEvent that has occurred.
            # portfolio_snapshot: A representation of the current portfolio state (optional).
            # historical_data: Access to historical data for signal calculation (optional).

        Returns:
            List[SignalEvent]: A list of SignalEvents generated by the strategy.
                               Returns an empty list if no signals are generated.
        """
        pass

# Example of a concrete strategy (for testing, can be moved to a separate file later)
class BuyAndHoldStrategy(Strategy):
    """
    A simple buy-and-hold strategy.
    Buys a fixed quantity of specified assets on the first market event and holds them.
    """
    def __init__(self, strategy_id: str, tickers_to_buy: Dict[str, float], 
                 description: Optional[str] = "Buys specified tickers on first data event and holds.",
                 params: Optional[Dict[str, Any]] = None):
        super().__init__(strategy_id, description, params)
        self.tickers_to_buy = tickers_to_buy # Dict of {"TICKER": quantity_to_buy}
        self.bought_flags = {ticker: False for ticker in tickers_to_buy}
        self.subscribe_tickers(list(tickers_to_buy.keys()))

    def calculate_signals(self, event: MarketEvent) -> List[SignalEvent]:
        signals = []
        if event.event_type == EventType.MARKET and event.security_ticker in self.tickers_to_buy:
            ticker = event.security_ticker
            if not self.bought_flags[ticker]:
                quantity = self.tickers_to_buy[ticker]
                signals.append(
                    SignalEvent(
                        timestamp=event.timestamp,
                        security_ticker=ticker,
                        order_type="BUY", # Using constants would be better: TransactionType.BUY
                        suggested_quantity=quantity
                    )
                )
                self.bought_flags[ticker] = True
                print(f"{self.strategy_id}: Generated BUY signal for {quantity} of {ticker} at {event.timestamp}")
        return signals

if __name__ == '__main__':
    # from ..core.event import EventType # For BuyAndHoldStrategy example # This is already imported above
    from datetime import datetime

    # Example Usage
    # 1. Create a BuyAndHoldStrategy instance
    buy_hold_strat = BuyAndHoldStrategy(
        strategy_id="BH_AAPL_GOOG",
        tickers_to_buy={"AAPL": 10, "GOOG": 5}
    )
    print(buy_hold_strat)
    print(f"Subscribed tickers: {buy_hold_strat.subscribed_tickers}")

    # 2. Simulate a MarketEvent
    market_event_aapl = MarketEvent(
        timestamp=datetime(2023, 1, 1, 10, 0, 0),
        security_ticker="AAPL",
        new_price=150.00
    )
    market_event_msft = MarketEvent( # A ticker not in the buy list
        timestamp=datetime(2023, 1, 1, 10, 0, 0),
        security_ticker="MSFT",
        new_price=300.00
    )
    market_event_goog = MarketEvent(
        timestamp=datetime(2023, 1, 1, 10, 5, 0),
        security_ticker="GOOG",
        new_price=2500.00
    )

    # 3. Calculate signals
    signals_aapl = buy_hold_strat.calculate_signals(market_event_aapl)
    print(f"Signals from AAPL event: {signals_aapl}")

    signals_msft = buy_hold_strat.calculate_signals(market_event_msft)
    print(f"Signals from MSFT event (should be none): {signals_msft}")
    
    signals_goog = buy_hold_strat.calculate_signals(market_event_goog)
    print(f"Signals from GOOG event: {signals_goog}")

    # Simulate another event for AAPL (should not generate new signal as it's already "bought")
    market_event_aapl_later = MarketEvent(
        timestamp=datetime(2023, 1, 2, 10, 0, 0),
        security_ticker="AAPL",
        new_price=152.00
    )
    signals_aapl_later = buy_hold_strat.calculate_signals(market_event_aapl_later)
    print(f"Signals from later AAPL event (should be none): {signals_aapl_later}")

    print(f"Strategy state after events: {buy_hold_strat.bought_flags}")
```
